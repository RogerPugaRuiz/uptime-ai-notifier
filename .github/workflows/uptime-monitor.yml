name: Monitor de Uptime

on:
  schedule:
    # Se ejecuta cada 15 minutos para no gastar los minutos gratis muy rápido
    # Si quieres cada 5 min, cambia a: '*/5 * * * *'
    - cron: '*/5 * * * *'
  # Esto te permite ejecutarlo manualmente con un botón para probar ya mismo
  workflow_dispatch:

env:
  # Configura tu sitio web aquí o usa un secret TARGET_URL
  TARGET: ${{ secrets.TARGET_URL || 'https://google.com' }}

jobs:
  check-status:
    runs-on: ubuntu-latest
    steps:
      - name: Verificar estado del sitio
        id: check
        run: |
          echo "Comprobando $TARGET..."

          # Hacemos la petición y guardamos el código HTTP (200, 404, 500, etc)
          # Con timeout de 30s y 3 reintentos para mayor robustez
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --max-time 30 \
            --retry 3 \
            --retry-delay 2 \
            "$TARGET")

          echo "Código recibido: $HTTP_CODE"

          # Aceptamos 200 (OK) y 302 (Redirección) como estados válidos
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "302" ]; then
            echo "¡Sitio caído! Enviando alerta a n8n..."

            # Enviamos el JSON con la estructura que tu n8n espera
            # Con timeout y manejo de errores
            if curl -L -X POST -H "Content-Type: application/json" \
              -d "{\"site\": \"$TARGET\", \"error_code\": \"$HTTP_CODE\", \"event\": \"site_down\"}" \
              --max-time 30 \
              --fail \
              --silent \
              --show-error \
              ${{ secrets.WEBHOOK_URL }}; then
              echo "Alerta enviada exitosamente a n8n"
            else
              echo "Error al enviar alerta a n8n (webhook podría estar inaccesible)"
              exit 1
            fi

            # Hacemos fallar el action para que salga rojo en GitHub
            
          else
            echo "El sitio está online. Todo correcto."
          fi
